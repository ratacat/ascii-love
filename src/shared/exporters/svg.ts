import { BASE_UNIT_PX } from '@shared/constants/canvas'

import type { Exporter } from './types'
import { buildExportDocument, deriveExportFilename, escapeXml } from './utils'

const CELL_SIZE = BASE_UNIT_PX
const FONT_FAMILY = "'Fira Code', 'IBM Plex Mono', 'DM Mono', monospace"
const FONT_SCALE = 0.85
const BASELINE_OFFSET = 0

const formatNumber = (value: number, fractionDigits = 2): string => {
  const rounded = Number.parseFloat(value.toFixed(fractionDigits))
  if (Number.isNaN(rounded)) {
    return '0'
  }
  return Object.is(rounded, -0) ? '0' : rounded.toString()
}

export const svgExporter: Exporter = {
  id: 'svg',
  label: 'SVG',
  description: 'Vector export with layer-ordered glyphs and palette-aware colors.',
  extension: 'svg',
  run: ({ document, selection, scope, padding, filename }) => {
    const exportDocument = buildExportDocument({ document, selection, scope, padding })
    const width = exportDocument.width * CELL_SIZE
    const height = exportDocument.height * CELL_SIZE
    const groupSelectors =
      (exportDocument.metadata.groupSelectors as Record<string, string> | undefined) ?? {}
    const groupAddressable = exportDocument.groups.reduce<Record<string, string>>((acc, group) => {
      if (group.addressableKey) {
        acc[group.id] = group.addressableKey
      }
      return acc
    }, {})

    const layerOrder = [...exportDocument.layers].sort((a, b) => a.zIndex - b.zIndex)
    const glyphElements: string[] = []

    layerOrder.forEach((layer) => {
      layer.glyphs.forEach((glyph) => {
        const transformTranslation = glyph.transform?.translation ?? { x: 0, y: 0 }
        const transformScale = glyph.transform?.scale ?? { x: 1, y: 1 }
        const transformRotation = glyph.transform?.rotation ?? 0
        const translateX =
          (glyph.position.x + 0.5) * CELL_SIZE + transformTranslation.x * CELL_SIZE
        const translateY =
          (glyph.position.y + 0.5) * CELL_SIZE + transformTranslation.y * CELL_SIZE + BASELINE_OFFSET
        const scaleX = transformScale.x ?? 1
        const scaleY = transformScale.y ?? 1

        const textFill = glyph.foreground ?? '#FFFFFF'

        const transforms: string[] = [
          `translate(${formatNumber(translateX)} ${formatNumber(translateY)})`,
        ]

        if (transformRotation) {
          transforms.push(`rotate(${formatNumber(transformRotation)})`)
        }

        if (scaleX !== 1 || scaleY !== 1) {
          transforms.push(
            `scale(${formatNumber(scaleX, 3)} ${formatNumber(scaleY, 3)})`,
          )
        }

        const text = `<text x="0" y="0" fill="${textFill}" font-size="${formatNumber(
          CELL_SIZE * FONT_SCALE,
        )}" font-family="${FONT_FAMILY}" text-anchor="middle" dominant-baseline="middle">${escapeXml(
          glyph.char,
        )}</text>`

        const selectorTokens = glyph.groupIds
          .map((groupId) => groupSelectors[groupId])
          .filter((token): token is string => Boolean(token))
        const addressableKeys = glyph.groupIds
          .map((groupId) => groupAddressable[groupId])
          .filter((key): key is string => Boolean(key))

        const attributes: string[] = [`data-layer="${escapeXml(layer.id)}"`]

        if (glyph.groupIds.length) {
          attributes.push(`data-groups="${escapeXml(glyph.groupIds.join(','))}"`)
        }

        if (selectorTokens.length) {
          attributes.push(`data-group-selectors="${escapeXml(selectorTokens.join(','))}"`)
          const classNames = selectorTokens.map((token) => `group-${escapeXml(token)}`).join(' ')
          attributes.push(`class="${classNames}"`)
        }

        if (addressableKeys.length) {
          attributes.push(`data-group-addressable="${escapeXml(addressableKeys.join(','))}"`)
        }

        attributes.push(`transform="${transforms.join(' ')}"`)

        glyphElements.push(`<g ${attributes.join(' ')}>${text}</g>`)
      })
    })

    const content = [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<!-- Generated by ASCII Asset Studio -->',
      `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" shape-rendering="crispEdges">`,
      '  <rect width="100%" height="100%" fill="transparent" />',
      glyphElements.map((element) => `  ${element}`).join('\n'),
      '</svg>',
    ].join('\n')

    return {
      filename:
        filename ??
        deriveExportFilename(
          document,
          scope,
          'svg',
          document.name ?? 'asset',
        ),
      mimeType: 'image/svg+xml',
      content,
    }
  },
}
