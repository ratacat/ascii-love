import type { Exporter } from './types'
import { buildExportDocument, deriveExportFilename, escapeXml } from './utils'

const CELL_SIZE = 18
const FONT_FAMILY = "'Fira Code', 'IBM Plex Mono', 'DM Mono', monospace"

export const svgExporter: Exporter = {
  id: 'svg',
  label: 'SVG',
  description: 'Vector export with layer-ordered glyphs and palette-aware colors.',
  extension: 'svg',
  run: ({ document, selection, scope, padding, filename }) => {
    const exportDocument = buildExportDocument({ document, selection, scope, padding })
    const width = exportDocument.width * CELL_SIZE
    const height = exportDocument.height * CELL_SIZE
    const groupSelectors =
      (exportDocument.metadata.groupSelectors as Record<string, string> | undefined) ?? {}
    const groupAddressable = exportDocument.groups.reduce<Record<string, string>>((acc, group) => {
      if (group.addressableKey) {
        acc[group.id] = group.addressableKey
      }
      return acc
    }, {})

    const layerOrder = [...exportDocument.layers].sort((a, b) => a.zIndex - b.zIndex)
    const glyphElements: string[] = []

    layerOrder.forEach((layer) => {
      layer.glyphs.forEach((glyph) => {
        const baseX = glyph.position.x * CELL_SIZE
        const baseY = glyph.position.y * CELL_SIZE

        const textX = baseX + CELL_SIZE / 2
        const textY = baseY + CELL_SIZE / 2 + 0.5
        const glyphGroups = glyph.groupIds.length ? ` data-groups="${escapeXml(glyph.groupIds.join(','))}"` : ''
        const textFill = glyph.foreground ?? '#FFFFFF'

        const text = `<text x="${textX.toFixed(2)}" y="${textY.toFixed(2)}" fill="${textFill}" font-size="${CELL_SIZE * 0.74}" font-family="${FONT_FAMILY}" text-anchor="middle" dominant-baseline="middle">${escapeXml(glyph.char)}</text>`

        const selectorTokens = glyph.groupIds
          .map((groupId) => groupSelectors[groupId])
          .filter((token): token is string => Boolean(token))
        const addressableKeys = glyph.groupIds
          .map((groupId) => groupAddressable[groupId])
          .filter((key): key is string => Boolean(key))

        const attributes: string[] = [`data-layer="${escapeXml(layer.id)}"`]

        if (glyph.groupIds.length) {
          attributes.push(`data-groups="${escapeXml(glyph.groupIds.join(','))}"`)
        }

        if (selectorTokens.length) {
          attributes.push(`data-group-selectors="${escapeXml(selectorTokens.join(','))}"`)
          const classNames = selectorTokens.map((token) => `group-${escapeXml(token)}`).join(' ')
          attributes.push(`class="${classNames}"`)
        }

        if (addressableKeys.length) {
          attributes.push(`data-group-addressable="${escapeXml(addressableKeys.join(','))}"`)
        }

        glyphElements.push(`<g ${attributes.join(' ')}>${text}</g>`)
      })
    })

    const content = [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<!-- Generated by ASCII Asset Studio -->',
      `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" shape-rendering="crispEdges">`,
      '  <rect width="100%" height="100%" fill="transparent" />',
      glyphElements.map((element) => `  ${element}`).join('\n'),
      '</svg>',
    ].join('\n')

    return {
      filename:
        filename ??
        deriveExportFilename(
          document,
          scope,
          'svg',
          document.name ?? 'asset',
        ),
      mimeType: 'image/svg+xml',
      content,
    }
  },
}
